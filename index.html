<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>nginx-cgi Documentation</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 0; line-height: 1.6; background: #f9fafb; color: #111827; }
    header { display: flex; justify-content: space-between; align-items: center; background: #1f2937; padding: 1rem 2rem; }
    header h1 { color: #fff; margin: 0; font-size: 1.5rem; }
    header h1 small { font-size: 1rem; font-style: italic; font-weight: normal; }
    header a { color: #fff; background: #2563eb; padding: 0.5rem 1rem; border-radius: 6px; text-decoration: none; font-weight: 600; }
    header a:hover { background: #1d4ed8; }
    main { max-width: 900px; margin: 2rem auto; padding: 0 1rem; background: #fff; border-radius: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); }
    main h1 { text-align: center; }
    main h2, main h3 { margin-top: 1.5rem; }
    pre { background: #1e293b; color: #f1f5f9; padding: 1rem; border-radius: 6px; overflow-x: auto; }
    code { padding: 2px 4px; border-radius: 4px; }
    footer { text-align: center; margin: 2rem 0; color: #6b7280; font-size: 0.9rem; }
    table { border-collapse: collapse; }
    table th, table td { padding: 6px 13px; border: 1px solid #d1d9e0; }
  </style>
</head>
<body>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WLGEHWFEBV"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-WLGEHWFEBV');
</script>

  <header>
    <h1>nginx-cgi
        <small>
          <!-- ver_start -->
v0.14.1
          <!-- ver_end -->
        </small>
    </h1>
    <a href="https://github.com/pjincz/nginx-cgi">View on GitHub â†’</a>
  </header>

  <main>
    <!-- doc_start -->
<h1>nginx-cgi plugin</h1>
<p>Brings CGI support to <a href="https://github.com/nginx/nginx">Nginx</a> and
<a href="https://github.com/webserver-llc/angie">Angie</a> webserver.</p>
<table>
<thead>
<tr>
<th>OS</th>
<th>Tested with</th>
<th>Nginx</th>
<th>Angie</th>
</tr>
</thead>
<tbody><tr>
<td>Linux</td>
<td>AlmaLinux 9, Debian 12 and Ubuntu 24.04/20.04</td>
<td>okay</td>
<td>okay</td>
</tr>
<tr>
<td>Darwin</td>
<td>MacOS 15.1</td>
<td>okay</td>
<td>okay</td>
</tr>
<tr>
<td>BSD</td>
<td>FreeBSD 14.2 and OpenBSD 7.6</td>
<td>okay</td>
<td>okay</td>
</tr>
<tr>
<td>Solaris</td>
<td>OmniOS r1510521</td>
<td>okay</td>
<td>okay</td>
</tr>
<tr>
<td>Windows</td>
<td>No plan, nginx barely supports Windows</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2>Before everything</h2>
<p>CGI is neither a demon nor an angel. It is simply a tool. Just like a chef&#39;s
knife in the hands of a cook or a sword in the hands of a warrior, you won&#39;t use
a sword for cooking, nor you take a chef&#39;s knife to the battlefield. The same
goes for CGI, it has its appropriate scenarios, and it should not be misused or
demonized.</p>
<p>CGI is good for:</p>
<ul>
<li>Low frequency applications, such as system management</li>
<li>Resource limited systems, such as embeding system</li>
<li>Low budget projects, such as personal websites</li>
<li>Prototyping, for fast iterate</li>
</ul>
<p>CGI is bad for:</p>
<ul>
<li>High QPS</li>
<li>High traffic</li>
<li>High concurrency</li>
</ul>
<p>I created a discord channel. If:</p>
<ul>
<li>You are also a fun of CGI</li>
<li>If you have any problem with nginx-cgi</li>
<li>If you want to get update of nginx-cgi</li>
<li>If you want to know more friends</li>
</ul>
<p>Please join us: <a href="https://discord.gg/EJSfqHHmaR">https://discord.gg/EJSfqHHmaR</a>.</p>
<h2>Quick start (with Debian 12+, Ubuntu 24.04+)</h2>
<p>Build and install:</p>
<pre><code class="language-sh"># checkout source code
git clone https://github.com/pjincz/nginx-cgi
cd nginx-cgi

# build deb package
./build-deb-package.sh

# install built package
dpkg -i ../libnginx-mod-http-cgi_*_amd64.deb 
</code></pre>
<p>Then enable cgi in nginx. If you have a newly installed nginx, you can find a
default site at <code>/etc/nginx/sites-enabled/default</code>. The default one looks like
this:</p>
<pre><code class="language-text">server {
    listen 80 default_server;
    listen [::]:80 default_server;

    root /var/www/html;

    index index.html index.htm index.nginx-debian.html;

    server_name _;

    location / {
        try_files $uri $uri/ =404;
    }
}
</code></pre>
<p>The default <code>root</code> points to <code>/var/www/html</code>, keep it as it as, and add
following section after <code>location /</code> section.</p>
<pre><code class="language-text">    location /cgi-bin {
        cgi on;
    }
</code></pre>
<p>The newly added section means, for all request under <code>/cgi-bin</code>, turns on cgi
support. Now restart nginx:</p>
<pre><code class="language-sh">systemctl restart nginx
</code></pre>
<p>Save following content to /var/www/html/cgi-bin/hello.sh</p>
<pre><code class="language-sh">#!/bin/bash

echo &quot;Content-Type: text/plain&quot;
echo

echo Hello CGI
</code></pre>
<p>Add x perm to cgi script:</p>
<pre><code class="language-sh">chmod +x /var/www/html/cgi-bin/hello.sh
</code></pre>
<p>Now, try it:</p>
<pre><code class="language-sh">curl http://127.0.0.1/cgi-bin/hello.sh
</code></pre>
<p>If you nothing wrong, you will get an output of <code>Hello CGI</code>.</p>
<h2>Build</h2>
<p>If you are using latest deb based system, such as Debian and Ubuntu, and not
willing to debug the plugin, you can just following the <code>Quick start</code> to get a
usable deb package.</p>
<p>If you are using Angie, the cgi plugin has already in Angie&#39;s official repo.
Please have a look here:
<a href="https://en.angie.software/angie/docs/installation/oss_packages/#install-thirdpartymodules-oss">https://en.angie.software/angie/docs/installation/oss_packages/#install-thirdpartymodules-oss</a></p>
<p>Manual build guide:</p>
<ol>
<li><p>Checkout nginx and this plugin</p>
<pre><code class="language-sh">cd &lt;some-where-you-like&gt;
git clone https://github.com/nginx/nginx
git clone https://github.com/pjincz/nginx-cgi
</code></pre>
</li>
<li><p>Generate Makefile in nginx dir</p>
<pre><code class="language-sh">cd nginx
./auto/configure --add-dynamic-module=$PWD/../nginx-cgi [...other option...]
</code></pre>
<p>If you want to debug the plugin, you may also want <code>--with-debug</code>.</p>
<p>If you want to build a module compatible with system&#39;s nginx, you need run
<code>nginx -V</code> to checkout system nginx&#39;s build options first.</p>
</li>
<li><p>Make the binary</p>
<pre><code class="language-sh">make
</code></pre>
</li>
</ol>
<p>If everything is good, then you will find <code>ngx_http_cgi_module.so</code> under <code>objs</code>
directory.</p>
<h2>Usage</h2>
<h3>Loading plugin</h3>
<p>If this plugin is installed to nginx&#39;s default module path (such as
<code>/usr/lib/nginx/modules</code>), the plugin will be loaded automatically.
Otherwise, you need to manually load the plugin by <code>load_module</code>.</p>
<p>Add following statement to nginx&#39;s top level context to load the plugin:</p>
<pre><code class="language-text">load_module &lt;dir-of-plugin&gt;/ngx_http_cgi_module.so;
</code></pre>
<h3>Enable cgi</h3>
<p>After loading the plugin, you can add <code>cgi on</code> to location contexts to enable
cgi. Example:</p>
<pre><code class="language-text">location /cgi-bin {
    cgi on;
}
</code></pre>
<p>Once cgi turned on on a location, all nested locations will also have cgi turned
on. If you want to disable cgi for a child location, just use <code>cgi off</code>.</p>
<p>When the location is accessed, nginx-cgi will find the script under the document
root (it&#39;s specified by <code>root</code> statement). For example, if you have specify the
document root as <code>/var/www/html</code>, then when you access <code>/cgi-bin/hello.sh</code>,
<code>/var/www/html/cgi-bin/hello.sh</code> will be executed.</p>
<p>Nginx-cgi also support <code>alias</code>, it like <code>root</code> statement in nginx, the only
difference is the location prefix will be removed from uri. For example, if you
want <code>/cgi/hello.sh</code> also reference to the same script, you can do this:</p>
<pre><code class="language-text">location /cgi {
    alias /var/www/html/cgi-bin;
    cgi on;
}
</code></pre>
<h3>Hello script</h3>
<p>A cgi script can be wrotten by any language. Here&#39;s an exmaple with shell. You
can save it to <code>/var/www/html/cgi-bin/hello.sh</code> for testing (if you didn&#39;t
change the default document root):</p>
<pre><code class="language-sh">#!/bin/sh

echo &quot;Status: 200 OK&quot;
echo &quot;Content-Type: text/plain&quot;
echo

echo &quot;Hello world&quot;
</code></pre>
<p>The first line of the script is a shebang. If you clearly set <code>cgi_interpreter</code>,
it&#39;s okay to remove this line, otherwise missing of shebang will causes a 500
error. Some shell allows script be executable even without shebang, but it&#39;s not
allowed here. If a script runable by shell, but return 500 error, check the
shebang.</p>
<p>The output of cgi script contains 2 sections: the header section and body
section. The first 2 <code>echo</code> statements output the header section, and the last
<code>echo</code> statement outputs the body section. The <code>echo</code> statement in middle
outputs the separator. Both header section and body section can be empty, but
the separator is mandatory. Missing of separator will causes an 500 error.</p>
<p>All lines in header section will be parsed as normal http response header line.
And then passed to the client side. There&#39;s one special header <code>Status</code>, it will
be passed in response status line. If <code>cgi_strict</code> is on, nginx-cgi will check
all cgi output headers, and 500 error will be responsed if invalid header found.
Otherwise, invalid headers will be forwarded to client side too. It&#39;s fully
recommanded to keep <code>cgi_strict</code> on.</p>
<p>After separator, all output will be sent to client as body as it is.</p>
<h3>x permission</h3>
<p>After all, you need to add the x permission to the file:</p>
<pre><code class="language-sh">chmod +x /var/www/html/cgi-bin/hello.sh
</code></pre>
<p>Normally, you need x-permission to make script runable. Missing of x-permission
can cause 403 error. If can&#39;t do this for any reason, <code>cgi_interpreter</code> can
help.</p>
<h3>Request header</h3>
<p>Request headers will be parsed and then translated to environment variables and
then passed to cgi script.</p>
<p>For example, you can find the query string in <code>QUERY_STRING</code> environment var.
And access <code>Http-Accept</code> by <code>HTTP_ACCPET</code>.</p>
<p>Here&#39;s an example:</p>
<pre><code class="language-sh">#!/bin/sh
echo &quot;&quot;

echo &quot;query string: $QUERY_STRING&quot;
echo &quot;http accept: $HTTP_ACCEPT&quot;
</code></pre>
<p>For full list of environment variables, see environment section.</p>
<h3>Request body</h3>
<p>The request body will be passed via stdin. Here&#39;s an example to read all request
body and echo it:</p>
<pre><code class="language-sh">#!/bin/sh
echo &quot;&quot;

body=$(cat)

echo &quot;request body: $body&quot;
</code></pre>
<h3>Streaming</h3>
<p>Nginx-cgi has streaming support for both request and response body. For example,
we can implement a simplest online caculator by <code>bc</code>:</p>
<pre><code class="language-sh">#!/bin/sh
echo &quot;&quot;

bc 2&gt;&amp;1
</code></pre>
<p>Then we can test our caculator by <code>curl</code>:</p>
<pre><code class="language-sh">curl 127.0.0.1/cgi-bin/bc.sh --no-progress-meter -T .
</code></pre>
<p>The nginx-cgi plugin is smart enough to choose the correct way to return the
request body. If it got all output soon enough, it will output the body in once.
If the output is delayed, it will output the body chunkly(HTTP 1.1) or
streamingly (HTTP 1.0).</p>
<h3>Hop-by-hop http headers</h3>
<p>Hop-by-hop http headers are not allowed in cgi script output. If it appears
in response here, a 500 error will response to the client.</p>
<p>For more information:
<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#hop-by-hop_headers">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#hop-by-hop_headers</a></p>
<h2>Tricks &amp;&amp; FAQ</h2>
<h3>I want to list all environment variables</h3>
<p>Put following script to your cgi directory, and curl it form your terminal:</p>
<pre><code class="language-sh">#!/bin/sh

echo &#39;Content-Type: text/plain&#39;
echo

printenv
</code></pre>
<h3>I want root permission</h3>
<p>Put a sudo file to <code>/etc/sudoers.d</code> and run <code>sudo</code> in your script or set
<code>cgi_interpreter</code> as <code>/usr/bin/sudo</code>.</p>
<p>Here&#39;s an example of sudo config file:</p>
<pre><code class="language-text"># allow wwww-data run /var/www/bin/my-danger-script with root account
www-data ALL=(root) NOPASSWD: /var/www/bin/my-danger-script

# allow all CGI script be launched with sudo by nginx-cgi directly
www-data ALL=(root) NOPASSWD: SETENV: /var/www/html/cgi-bin/*
</code></pre>
<h3>How can I run CGI scripts with chroot</h3>
<p>It&#39;s highly not recommanded to run CGI script with chroot. Because chroot is not
designed for security purpose. It still shared a lot of kernel spaces with host
system. For example, run <code>ps -ef</code> in chrooted process, all processes in host
system will return. That sould not too aweful? No, that&#39;s really terrible,
because you can also do <code>kill</code> in chrooted script for the same reason. And
people normally run programs with root permission in chrooted environment.
That&#39;s terribly bad. It causes system on high risk than just run script with
<code>www-data</code>.</p>
<p>If you want a sandbox environment, <code>lxc</code>, <code>docker</code> and <code>jails</code> are much better
for this purpose.</p>
<p>If you still want <code>chroot</code>, okay let me show you how to do it.</p>
<p>In this example, I assume you&#39;re using <code>/var/www/html</code> as the document root.</p>
<p>Prepare a CGI script first:</p>
<pre><code class="language-sh">mkdir -p /var/www/html/cgi-bin
cat &gt; /var/www/html/cgi-bin/ls.sh &lt;&lt;EOF
#!/bin/sh
echo &quot;Status: 200&quot;
echo &quot;Content-Type: text-plain&quot;
echo
echo &quot;files under /:&quot;
ls /
EOF
chmod +x /var/www/html/cgi-bin/ls.sh

# try it
/var/www/html/cgi-bin/ls.sh
</code></pre>
<p>Step 1: prepare a chroot directory.</p>
<p>That&#39;re a lot of ways to do this step. <code>debootstrap</code> is a popular way on debian
based system. <code>busybox</code> is the most light way. <code>docker</code> is a modern way.</p>
<p>Let&#39;s make a lightest directory with <code>busybox</code> here:</p>
<pre><code class="language-sh"># In this example, I put everything to /var/www/chroot
# Be careful, I download x86_64 busybox version here, you may need to change it
# You need root permission to run all following commands, I&#39;m too lazy to
# prepend sudo to every commands here.

root_dir=/var/www/chroot

mkdir -p &quot;$root_dir/bin&quot; &amp;&amp; cd &quot;$root_dir/bin&quot;
wget https://www.busybox.net/downloads/binaries/1.35.0-x86_64-linux-musl/busybox
chmod +x busybox

cd &quot;$root_dir&quot;
mkdir -p $(dirname $(./bin/busybox --list-full) | sort -u)
./bin/busybox --list-full | while read line; do ln -sf /bin/busybox $line; done

# try it
chroot &quot;$root_dir&quot; ls
</code></pre>
<p>Step 2: mount document root into chroot dir</p>
<pre><code class="language-sh">mkdir -p /var/www/chroot/var/www/html
mount --bind /var/www/html /var/www/chroot/var/www/html

# try it
ls /var/www/chroot/var/www/html
</code></pre>
<p>Notice:</p>
<ul>
<li><p>I use a trick here, after chroot, the document root is still the same. By this
we can same some time to do path mapping.</p>
</li>
<li><p>The mounting will not persist after a reboot. You may need to add an entry to
/etc/fstab. Or move /var/www/html into chroot, and make a symbolic link
outside.</p>
</li>
</ul>
<p>Step 3: allow <code>www-data</code> to run <code>chroot</code> with root permission.</p>
<pre><code class="language-sh">cat &gt;/etc/sudoers.d/www-run-with-chroot &lt;&lt;EOF
# allow and only allow www-data run chroot with /var/www/chroot
www-data ALL=(root) NOPASSWD: /usr/sbin/chroot /var/www/chroot *
EOF
</code></pre>
<p>Now everything is ready, add following section to your nginx/angie:</p>
<pre><code class="language-conf">location /cgi-bin {
    cgi on;
    cgi_interpreter /usr/bin/sudo /usr/sbin/chroot /var/www/chroot;
}
</code></pre>
<p>try it:</p>
<pre><code class="language-sh">curl 127.0.0.1/cgi-bin/ls.sh
</code></pre>
<h3>How can I run CGI scripts with docker</h3>
<p>In this example, I assume you&#39;re using <code>/var/www/html</code> as the document root.</p>
<p>Prepare a CGI script first:</p>
<pre><code class="language-sh">mkdir -p /var/www/html/cgi-bin
cat &gt; /var/www/html/cgi-bin/ls.sh &lt;&lt;EOF
#!/bin/sh
echo &quot;Status: 200&quot;
echo &quot;Content-Type: text-plain&quot;
echo
echo &quot;files under /:&quot;
ls /
EOF
chmod +x /var/www/html/cgi-bin/ls.sh

# try it
/var/www/html/cgi-bin/ls.sh
</code></pre>
<p>Create a container and keep running in the background:</p>
<pre><code class="language-sh"># Change -v if necessary
# -d: runs background
# -i -t: keep a terminal
# --restart always: keep container alive
docker run -dit --restart always --name my_cgi_docker -v /var/www:/var/www busybox sh

# try it
docker exec my_cgi_docker /var/www/html/cgi-bin/ls.sh
</code></pre>
<p>Allow <code>www-data</code> to run <code>docker</code> commands:</p>
<pre><code class="language-sh">sudo usermod -aG docker www-data

# try it
sudo -u www-data docker exec my_cgi_docker /var/www/html/cgi-bin/ls.sh
</code></pre>
<p>Now everything is ready, add following section to your nginx/angie:</p>
<pre><code class="language-conf">location /cgi-bin {
    cgi on;
    cgi_interpreter /usr/bin/docker exec my_cgi_docker;
}
</code></pre>
<h3>How can I run CGI scripts with jails</h3>
<p>Okay, you&#39;re a fan of FreeBSD? Me too.</p>
<p>It&#39;s really similar to running scripts with <code>chroot</code>.</p>
<p>Here I assume you&#39;re using <code>/var/www/html</code> as the document root too.</p>
<p>Prepare a CGI script first:</p>
<pre><code class="language-sh">mkdir -p /var/www/html/cgi-bin
cat &gt; /var/www/html/cgi-bin/ls.sh &lt;&lt;EOF
#!/bin/sh
echo &quot;Status: 200&quot;
echo &quot;Content-Type: text-plain&quot;
echo
echo &quot;files under /:&quot;
ls /
EOF
chmod +x /var/www/html/cgi-bin/ls.sh

# try it
/var/www/html/cgi-bin/ls.sh
</code></pre>
<p>Step 1: create a jail</p>
<p>Let&#39;s put the jail to <code>/var/www/jail</code>.</p>
<pre><code class="language-sh">mkdir -p /var/www/jail &amp;&amp; cd /var/www/jail
fetch https://download.freebsd.org/ftp/releases/$(uname -m)/$(uname -m)/$(uname -r)/base.txz
tar -xvf base.txz -C .

# create mount points
mkdir -p /var/www/jail/var/www/html
touch /var/www/jail/etc/resolv.conf
</code></pre>
<p>Put following config to <code>/etc/jail.conf</code>:</p>
<pre><code class="language-conf">www-jail {
    path = &quot;/var/www/jail&quot;;
    host.hostname = &quot;www-jail.local&quot;;

    exec.clean;
    exec.start = &quot;/bin/sh /etc/rc&quot;;
    exec.stop = &quot;/bin/sh /etc/rc.shutdown&quot;;

    # mount /var/www/html =&gt; /var/www/jail/var/www/html
    exec.prestart += &quot;mount_nullfs /var/www/html /var/www/jail/var/www/html || true&quot;;
    mount.devfs;

    # uncomment following lines, if you want to allow network access in jail
    # ip4 = inherit;
    # ip6 = inherit;
    # exec.prestart += &quot;mount_nullfs /etc/resolv.conf /var/www/jail/etc/resolv.conf || true&quot;;

    # uncomment fowlling lines, if you also want `ping` available in jail
    # allow.raw_sockets = 1;

    persist; # keep jail if no process runs
}
</code></pre>
<p>And ensure that following line appears in <code>/etc/rc.conf</code>:</p>
<pre><code class="language-conf">jail_enable=&quot;YES&quot;
</code></pre>
<p>And start the jail:</p>
<pre><code class="language-sh">service jail start www-jail

# try it
jexec www-jail ls /
jexec www-jail /var/www/html/cgi-bin/ls.sh
</code></pre>
<p>Step 2: allow <code>www</code> to run <code>jexec</code> with root permission.</p>
<p>I uses <code>sudo</code> here. I&#39;m not familiar with <code>doas</code>, if you prefer <code>doas</code> you can
try it yourself. Anyhow, neither <code>sudo</code> nor <code>doas</code> preloaded with FreeBSD. You
need to manually install one of them.</p>
<pre><code class="language-sh">cat &gt;/usr/local/etc/sudoers.d/www-jexec &lt;&lt;EOF
# allow and only allow `www` run `jexec` with `www-jail`
www ALL=(root) NOPASSWD: /usr/sbin/jexec www-jail *
EOF

# try it
sudo -u www sudo jexec www-jail /var/www/html/cgi-bin/ls.sh
</code></pre>
<p>Now everything is ready, add following section to your nginx/angie:</p>
<pre><code class="language-conf">location /cgi-bin {
    cgi on;
    cgi_interpreter /usr/local/bin/sudo /usr/sbin/jexec www-jail;
}
</code></pre>
<p>try it:</p>
<pre><code class="language-sh">curl 127.0.0.1/cgi-bin/ls.sh
</code></pre>
<h3>I want create a long-run background process</h3>
<p>Just make sure not to inherit <code>stdout</code> when creating the process (ideally, avoid
inheriting <code>stdin</code> and <code>stderr</code> as well). Here&#39;s an example write in shell.</p>
<pre><code class="language-sh">taskid=1234
logfile=&quot;/var/lib/my-project/$taskid&quot;
./long-run-task.sh &quot;$taskid&quot; &lt;/dev/null &gt;&quot;$logfile&quot; 2&gt;&amp;1 &amp;
</code></pre>
<p>Or if you are familiar with pipe operation, just close <code>stdout</code> (also, it&#39;s
better to close <code>stdin</code> and <code>stderr</code> as well), http request will finished
immediently. And you can use the process as background process.</p>
<pre><code class="language-sh">exec &lt;/dev/null &gt;somewhere 2&gt;&amp;1

# now http response is done, do what every you like
sleep 9999
</code></pre>
<h3>My http request hangs</h3>
<p>As you see abvoing. In CGI world, http request&#39;s lifecycle depends on pipe&#39;s
(stdout&#39;s) lifecycle.</p>
<p>Each child process might inherit the CGI process&#39;s pipe. If any process that
inherited stdout remains alive, the HTTP request will never finish.</p>
<p>This may causes confiusing, when you want a long run background or killing
CGI process.</p>
<p>For creating long-run process, see aboving topic.</p>
<p>For killing CGI process, kill the whole process group rather than CGI process
itself.</p>
<pre><code class="language-sh">cgi_pid=...

# don&#39;t do this
# kill &quot;$cgi_pid&quot;

# do this
kill -- &quot;-$cgi_pid&quot;
</code></pre>
<h3>I want to kill my cgi script</h3>
<p>See aboving topic.</p>
<h3>I want to generate content dynamicaly</h3>
<p>Traditionally, people use rewriting to archive this. But it&#39;s much easier here.
You can do it with <code>cgi pass</code>. Here&#39;s an example to render markdone dynamically:</p>
<pre><code class="language-conf">{
    location ~ ^.*\.md$ {
        cgi_pass /var/www/bin/cgi/render-markdown.sh;
    }
}
</code></pre>
<pre><code class="language-sh">#!/bin/sh

set -e

if [ ! -f &quot;${DOCUMENT_ROOT}${PATH_INFO}&quot; ]; then
    echo &quot;Status: 404&quot;
    echo
    exit
fi

echo &quot;Status: 200&quot;
echo &quot;Content-Type: text/html&quot;
echo

echo &quot;&lt;html&gt;&lt;body&gt;&quot;
markdown &quot;${DOCUMENT_ROOT}${PATH_INFO}&quot;
echo &quot;&lt;/body&gt;&lt;/html&gt;&quot;
</code></pre>
<h3>I don&#39;t like suffixes in url</h3>
<p>Way 1: Removing CGI script&#39;s suffix</p>
<p>Way 2: do rewriting</p>
<p>Way 3: <code>cgi pass</code></p>
<h3>How can I response status other than 200</h3>
<pre><code class="language-sh">#!/bin/sh

echo &quot;Status: 404&quot;
echo &quot;Content-Type: text/plain&quot;
echo

echo &quot;Welcome to the void&quot;
</code></pre>
<h3>How can I response a redirection</h3>
<pre><code class="language-sh">#!/bin/sh

echo &quot;Status: 302&quot;
echo &quot;Location: https://theuselessweb.com&quot;
echo
</code></pre>
<h3>How can I get http request body</h3>
<p>You can read the request body from <code>stdin</code>. If you&#39;re using shell, <code>cat</code> can
quickly save request body to a file.</p>
<h3>How can send file to the client</h3>
<p>For small files, you can write file to <code>stdout</code> directly.</p>
<p>For large files, it&#39;s much better to send a 302 response. Because CGI response
is streaming, protocol cannot easily handle caching, chunked downloads, or
resume support.</p>
<h3>I want to write CGI with python, ruby, perl, C, C++...</h3>
<p>Go for it. Nginx-cgi don&#39;t care what language you use. Just grabs information
from environment var, and read request body from <code>stdin</code>, and write output to
<code>stdout</code>.</p>
<h2>Manual</h2>
<h3>Options</h3>
<h4><code>cgi &lt;on|off&gt;</code> or <code>cgi pass &lt;script_path&gt; [script_args...]</code></h4>
<p>Enable or disable cgi module on giving location block.</p>
<p>If you specify <code>on</code> here, the plugin will work in traditional mode. It parses
the request uri first, and then locate the script under document root directory
with request uri. After all it splits request uri to <code>SCRIPT_NAME</code> and
<code>PATH_INFO</code>. This is good if you have an old CGI project or you want to strictly
follow rfc3875.</p>
<p>I also provided a nginx style syntax here. If you specify <code>cgi pass</code> here, the
plugin will skip the step to locate the CGI script. It uses the the value you
provided directly. You can references nginx variables in the second argument,
eg: <code>cgi pass $document_root$uri</code>. The aboving example do something similar to
rfc3875, but not equal. In this form, request uri will be assigned to
<code>PATH_INFO</code> directly. And <code>SCRIPT_NAME</code> will be empty. This form is really good
for dynamic content generating. It gets around the complex and unnecessary uri
re-writing.</p>
<p>Additionally, the second form also provides you the ability to pass additional
args to script, eg: <code>cgi pass my_script.sh $uri</code>. With this, you can totally
avoid confusing rfc3875 environment variables.</p>
<p>If you specify <code>off</code> here, the plugin will be disabled.</p>
<p>Default: off</p>
<h4><code>cgi_pass &lt;script_path&gt;</code></h4>
<p>Alias of <code>cgi pass &lt;script_path&gt;</code>.</p>
<h4><code>cgi_interpreter [interpreter] [args...]</code></h4>
<p>Set interpreter and interpreter args for cgi script.</p>
<p>When this option is not empty, cgi script will be run with giving interpreter.
Otherwise, script will be executed directly.</p>
<p>This option can contains nginx variables, see
<a href="https://nginx.org/en/docs/varindex.html">https://nginx.org/en/docs/varindex.html</a> for more details.</p>
<p>This option is extremely useful in a lot of senarios, for example:</p>
<ul>
<li>run CGI scripts missing x-perm</li>
<li>do sudo before executing CGI script</li>
<li>wrap general binary as CGI script</li>
<li>filter CGI script output</li>
<li>...</li>
</ul>
<p>Default: empty</p>
<h4><code>cgi_working_dir &lt;dir&gt;</code></h4>
<p>Set the working directory of CGI script.</p>
<p>If this value is set to empty, CGI scripts will inherit nginx&#39; working
directory.</p>
<p>If this value is set to an non-empty string, the CGI script will be launched
with giving working directory.</p>
<p>The action of changing working directory may failed. For example, giving
directory doesn&#39;t exist, no perm or name too long. In this case, script will
failed to execute.</p>
<p>This option doesn&#39;t change the way to find interpreter or script (if they are
specified with related path, they are always related to nginx&#39; working
directory).</p>
<p>This option can contain nginx variable. Althrough I don&#39;t know what use this is.
Maybe you can setup different working dir for different server_name by this.</p>
<p>Default: empty</p>
<h4><code>cgi_body_only &lt;on|off&gt;</code></h4>
<p>A standard CGI script should output two parts: header and body. And an empty
line to split those two parts.</p>
<p>If you want to simply run a normal program as CGI program. You can turn this on.</p>
<p>Once this option is enabled, all outout will be treated as response body, and be
sent to the client.</p>
<p>Default: off</p>
<h4><code>cgi_path &lt;PATH&gt;</code></h4>
<p>Change cgi script PATH environment variable.</p>
<p>Default: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</p>
<h4><code>cgi_strict &lt;on|off&gt;</code></h4>
<p>Enable or disable strict mode.</p>
<p>When strict mode turns on, bad cgi header will cause 500 error. When strict mode
turns off, bad cgi header be forward as it is.</p>
<p>Default: on</p>
<h4><code>cgi_set_var &lt;name&gt; &lt;value&gt;</code></h4>
<p>Add and pass extra environment variables to CGI script. The first argument of
this command is the name of environment variable. It should contains only
alphabets, numbers and underscore, and doesn&#39;t start with number. The second
argument of this command is the value express of the var. It can contains nginx
variables, see <a href="https://nginx.org/en/docs/varindex.html">https://nginx.org/en/docs/varindex.html</a> for more details.</p>
<p>This option can appears more than 1 time to set multiple variables. If more than
one option set the same var, then the last one works. These directives are
inherited from the previous configuration level if and only if there&#39;s no
cgi_set_var directives defined on the current level.</p>
<p>This option can also be used to override standard CGI vars. This may be useful
in some case, for example hacking old CGI script or simulate standard vars that
are not supported by this plugin now (Such as <code>PATH_TRANSLATED</code>,
<code>REMOTE_IDENT</code>). But it&#39;s not recommanded, it may introduce confusing issues to
your system.</p>
<h4><code>cgi_stderr &lt;path&gt;</code></h4>
<p>Redirect cgi stderr to giving file.</p>
<p>By default, nginx-cgi grab cgi script&#39;s stderr output and dump it to nginx log.
But this action is somewhat expensive, because it need to create an extra
connection to listen stderr output. If you want to avoid this, you can use this
option to redirect cgi script&#39;s stderr output to a file. Or you can even discard
all stderr output by redirect to <code>/dev/null</code>. Also you can use this to redirect
all stderr output to nginx&#39;s stderr by set it as <code>/dev/stderr</code>.</p>
<h4><code>cgi_rdns &lt;on|off|double&gt; [required]</code></h4>
<p>Enable or disable reverse dns.</p>
<p><code>off</code>: disable rdns feature.</p>
<p><code>on</code>: Do reverse dns before launching cgi script, and pass rdns result to cgi
script via <code>REMOTE_HOST</code> environment variable.</p>
<p><code>double</code>: After reverse dns, do a forward dns again to check the rdns result. if
result matches, pass result as <code>REMOTE_HOST</code>.</p>
<p><code>required</code>: If rdns failed, 403, 503 or 500 returns to the client. Depends on
the failure reason of rdns.</p>
<p>If you turns this option on, you need to setup a <code>resolver</code> in nginx too.
Otherwise you will get an error of <code>no resolver defined to resolve</code>.</p>
<p><strong>author notes</strong>: do not enable this option, it will makes every request slower.
this feature can be easily implemented by <code>dig -x</code> or <code>nslookup</code> in script. the
only reason I implement this is just to make the module fully compliant with the
rfc3875 standard.</p>
<h4><code>cgi_timeout &lt;t1&gt; [t2]</code></h4>
<p>Send <code>TERM</code>/<code>KILL</code> signals to the CGI process if it runs too long.</p>
<p>If both <code>t1</code> and <code>t2</code> equal to <code>0</code>. Timeout feature is disabled.</p>
<p>If <code>t1</code> or <code>t2</code> doesn&#39;t equal to <code>0</code>. A <code>TERM</code> or <code>KILL</code> signal will be sent to
the process after timeout.</p>
<p>If both <code>t1</code> and <code>t2</code> not zero. Send <code>TERM</code> at <code>t1</code> timestamp first. And send
<code>KILL</code> again at <code>t1+t2</code> timestamp (if process still alive at that timestamp).</p>
<p>If <code>t2</code> doesn&#39;t present, it treated as <code>0</code>.</p>
<p>Default: 0 0</p>
<h3>Standard Environment Variables</h3>
<p>Nginx-cgi implemented almost all rfc3875 standard variables. If they cannot
cover all of your usage, you can add your own variable by <code>cgi_set_var</code>. Also
those variables can be overrided by <code>cgi_set_var</code> if you really want to.</p>
<ul>
<li><code>AUTH_TYPE</code>, <code>REMOTE_USER</code> (rfc3875 standard)</li>
</ul>
<p>If cgi script is behind an authorization module (such as
<code>ngx_http_auth_basic_module</code>), and the authorization is succeed, the value is
set to auth type (such as <code>Basic</code>) and authorized user.</p>
<p>If no authorization module enabled, no matter client passes autoriazation header
or not. Those 2 fields are not present.</p>
<p><code>Authorization</code> header is not visible in cgi script for security reason. If you
really want to do authorization in CGI script, try <code>cgi_set_var</code>.</p>
<ul>
<li><code>CONTENT_LENGTH</code>, <code>CONTENT_TYPE</code> (rfc3875 standard)</li>
</ul>
<p>Same to request header&#39;s <code>Content-Length</code> and <code>Content-Type</code>.</p>
<ul>
<li><code>GATEWAY_INTERFACE</code> (rfc3875 standard)</li>
</ul>
<p>Always be <code>CGI/1.1</code> in this plugin.</p>
<ul>
<li><code>PATH_INFO</code> (rfc3875 standard)</li>
</ul>
<p>Let&#39;s say if you have a script under <code>/cgi-bin/hello.sh</code>, and you access
<code>http://127.0.0.1/cgi-bin/hello.sh/somewhat</code>.</p>
<p>Then <code>PATH_INFO</code> contains the string <code>/somewhat</code>.</p>
<p>Combination with url <code>rewrite</code> or <code>cgi pass</code>, this variable can be used for
dynamic content generating.</p>
<ul>
<li><code>PATH_TRANSLATED</code> (rfc3875 standard)</li>
</ul>
<p><strong>Note</strong>: this option is not implemented strictly compliant with rfc3875.
Please avoid this, if you are writing new CGI script.</p>
<p>This is related to <code>PATH_INFO</code>.</p>
<p>Let&#39;s say if you have a script under <code>/cgi-bin/hello.sh</code>, and you access
<code>http://127.0.0.1/cgi-bin/hello.sh/somewhat</code>.</p>
<p>The standard says, the server should try again with <code>http://127.0.0.1/somewhat</code>,
and found out where the uri should mapped to.</p>
<p>For technical reason, I just construct this variable by document root and
<code>PATH_INFO</code>.</p>
<p>The behaviour may be changed in future version.</p>
<ul>
<li><code>QUERY_STRING</code> (rfc3875 standard)</li>
</ul>
<p>Contains the query string of the request. For example, if you are accessing
<code>http://127.0.0.1/cgi-bin/hello.sh?a=1&amp;b=2</code>, <code>QUERY_STRING</code> will contains
<code>a=1&amp;b=2</code>.</p>
<ul>
<li><code>REMOTE_ADDR</code>, (rfc3875 standard)</li>
</ul>
<p>Client ip address.</p>
<ul>
<li><code>REMOTE_HOST</code> (rfc3875 standard)</li>
</ul>
<p>Client host name. Only available if <code>cgi_rdns</code> is turns on.</p>
<p>If <code>cgi_rdns</code> is on, nginx-cgi will do a reverse DNS, and find a domain matches
<code>REMOTE_ADDR</code>. If any found, it will be set to <code>REMOTE_HOST</code>.</p>
<p>If <code>cgi_rdns</code> is double, after the RDNS, nginx-cgi will do a forward DNS again.
<code>REMOTE_HOST</code> will only be set if the forward DNS result matches the original
address.</p>
<p>See <code>cgi_rdns</code> for more information.</p>
<ul>
<li><code>REMOTE_IDENT</code> (rfc3875 standard)</li>
</ul>
<p>Nginx-cgi plugin doesn&#39;t support this for security reason.</p>
<ul>
<li><code>REQUEST_METHOD</code> (rfc3875 standard)</li>
</ul>
<p>Request method of the request, for example: <code>GET</code>, <code>POST</code>...</p>
<ul>
<li><code>SCRIPT_NAME</code> (rfc3875 standard)</li>
</ul>
<p>Path to current script. Normally, you don&#39;t need this. It doesn&#39;t contains the
full path. See <code>SCRIPT_FILENAME</code>.</p>
<p>The only reason to use this is construct the URI after rewriting. You can use
<code>SCRIPT_NAME</code> + <code>PATH_INFO</code> to get the URI after rewriting.</p>
<ul>
<li><code>SERVER_NAME</code> (rfc3875 standard)</li>
</ul>
<p>Server name, normally it equals to <code>Host</code> header without port part. If <code>Host</code>
header doesn&#39;t appear in the request (HTTP/1.0) or contains invalid value, then
this value is set to the reflect server ip address. If the ip address is an ipv6
address, it will be quoted with bracket like <code>[::1]</code>.</p>
<ul>
<li><code>SERVER_PORT</code> (rfc3875 standard)</li>
</ul>
<p>Server listening port, such as <code>80</code>, <code>443</code>...</p>
<ul>
<li><code>SERVER_PROTOCOL</code> (rfc3875 standard)</li>
</ul>
<p>The protocol used between client and server. Such as <code>HTTP/1.0</code>, <code>HTTP/1.1</code>...</p>
<ul>
<li><code>SERVER_SOFTWARE</code> (rfc3875 standard)</li>
</ul>
<p>Contains a string of nginx and version, such as <code>nginx/1.27.4</code>.</p>
<ul>
<li><code>X_</code> (rfc3875 standard)</li>
</ul>
<p>All <code>X-</code> prefixed http request header will be convert to <code>X_</code> variables. For
example:</p>
<p>If <code>X-a: 123</code> appears in header, <code>X_A</code> will be set to <code>123</code>.</p>
<ul>
<li><code>HTTP_</code> (rfc3875 standard)</li>
</ul>
<p>All other http request header will be convert to <code>HTTP_</code> variables, for example:</p>
<p>If <code>Accept: */*</code> appears in header, <code>HTTP_ACCEPT</code> will be set to <code>*/*</code>.</p>
<ul>
<li><code>DOCUMENT_ROOT</code> (non-standard, impled by apache2)</li>
</ul>
<p>Document root of current location block, see <code>root</code> stmt in nginx.</p>
<ul>
<li><code>REMOTE_PORT</code> (non-standard, impled by apache2)</li>
</ul>
<p>Client port number.</p>
<ul>
<li><code>REQUEST_SCHEME</code> (non-standard, impled by apache2)</li>
</ul>
<p><code>http</code> or <code>https</code>.</p>
<ul>
<li><code>REQUEST_URI</code> (non-standard, impled by apache2)</li>
</ul>
<p>The raw uri before rewriting. If you want the URL after rewriting, try
<code>SCRIPT_NAME</code> + <code>PATH_INFO</code>.</p>
<p>Note: this variable doesn&#39;t same to nginx varible <code>$request_uri</code>. You can find
the document at <a href="https://httpd.apache.org/docs/2.4/mod/mod_rewrite.html">https://httpd.apache.org/docs/2.4/mod/mod_rewrite.html</a>.</p>
<ul>
<li><code>SCRIPT_FILENAME</code> (non-standard, impled by apache2)</li>
</ul>
<p>The full path to the CGI script.</p>
<ul>
<li><code>SERVER_ADDR</code> (non-standard, impled by apache2)</li>
</ul>
<p>Server ip address. If the server has multiple ip addresses. The value of this
variable can be different if requests came from different interfaces.</p>
<h2>Known Issues</h2>
<h3><code>PATH_TRANSLATED</code> impl not accurate</h3>
<p>By rfc3875, <code>PATH_TRANSLATED</code> should point to the file that as if <code>$PATH_INFO</code>
accessed as <code>uri</code>. But that&#39;s really hard to impl on nginx, it need re-trigger
nginx&#39;s location process. And those functions are private, cannot access by
plugin directly. The another way to impl it is starting a sub-request, but it&#39;s
too expensive, and this var is really rearly used. It&#39;s really not worth to do
it. So I simply construct this var by document root and <code>path_info</code> vars.</p>
<h3>RDNS impl doesn&#39;t access /etc/hosts</h3>
<p>Nginx&#39;s resolver impl doesn&#39;t access /etc/hosts. I don&#39;t want to impl an extra
resolver in plugin. So I just ignore this problem.</p>
<h2>Reference</h2>
<h2>rfc3875</h2>
<p><a href="https://datatracker.ietf.org/doc/html/rfc3875">https://datatracker.ietf.org/doc/html/rfc3875</a></p>
<h3>nginx</h3>
<p><a href="https://nginx.org/en/docs/dev/development_guide.html">https://nginx.org/en/docs/dev/development_guide.html</a>
<a href="https://hg.nginx.org/nginx-tests">https://hg.nginx.org/nginx-tests</a></p>
<h3>Hop-by-hop headers</h3>
<p><a href="https://datatracker.ietf.org/doc/html/rfc2616#section-13.5.1">https://datatracker.ietf.org/doc/html/rfc2616#section-13.5.1</a></p>
<h3>CGI environments</h3>
<p><a href="https://datatracker.ietf.org/doc/html/rfc3875#section-4.1">https://datatracker.ietf.org/doc/html/rfc3875#section-4.1</a></p>
<h3>Apache CGI</h3>
<p><a href="https://httpd.apache.org/docs/2.4/howto/cgi.html">https://httpd.apache.org/docs/2.4/howto/cgi.html</a></p>
<h3>Lighttpd CGI</h3>
<p><a href="https://redmine.lighttpd.net/projects/lighttpd/wiki/Mod_cgi">https://redmine.lighttpd.net/projects/lighttpd/wiki/Mod_cgi</a></p>
<h2>License</h2>
<p><a href="LICENSE">2-clause BSD license</a></p>

    <!-- doc_end -->
  </main>
</body>
</html>
